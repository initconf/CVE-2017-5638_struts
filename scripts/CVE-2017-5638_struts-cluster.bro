# script to look for CONTENT-TYPE attacks in Apache Struts CVE-2017-5638
# original author: Scott Campbell, scampbell@lbl.gov
# extended further  by aashish sharma, asharma@lbl.gov 
#

module Struts; 

@load base/frameworks/notice/main

export {
        redef enum Notice::Type += {
	 	Attempt,
		MalwareURL, 
                HostileDomainLookup,
                MalwareURLClick,
		FileDownload, 
                Compromise,
        };

	const detection_string = /\/etc\/init\.d\/iptables stop|service iptables stop|SuSEfirewall2 stop|reSuSEfirewall2 stop|cmd\.exe|\/bin\/bash|java.lang.ProcessBuilder/ &redef;
	#const detection_string = /\.png|\.jpg|\/etc\/init\.d\/iptables stop|service iptables stop|SuSEfirewall2 stop|reSuSEfirewall2 stop|cmd\.exe|\/bin\/bash|java.lang.ProcessBuilder/ &redef;

	redef detection_string += /^[^\r\n]*filename\s*=\s*[^\x3b\x3a\r\n]*[\x25\x24]\s*\{[^\r\n]{20,}\}/ ; 
	redef detection_string += /^[^\r\n]*filename\s*=\s*[^\x3b\x3a\r\n]*[\x25\x24]\s*\{[^\r\n]{20,}\}/|/^Content-Length\x3a\x20\d{10,}\r?\n/ ; 
	#redef detection_string += /^Content-Disposition\x3a[^\r\n]*?\{(?=[^\r\n]*java\.)[^\r\n]*\.ognl[^\r\n]*\}/ ; 
	#redef detection_string += /^Content-Disposition\x3a[^\r\n]*?\{(?=[^\r\n]*java\.)[^\r\n]*\.ognl[^\r\n]*\}/; 

	redef detection_string += /_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS|wmres=#context\['com.opensymphony.xwork2.dispatcher.HttpServletResponse|wmres.getWriter\(\).print\(\"S2-045 dir --\*\*\*\"\)\)/;


	const url_regex = /^https?:\/\/([a-z0-9A-Z]+(:[a-zA-Z0-9]+)?@)?[-a-z0-9A-Z\-]+(\.[-a-z0-9A-Z\-]+)*((:[0-9]+)?)(\/[a-zA-Z0-9;:\/\.\-_+%~?&amp;@=#\(\)]*)?/ ;
	global watch_mime_types: pattern = /application\/x-dosexec|application\/x-executable/ &redef ;

	global struts_malware_hosts: set[addr] ; 

	type struts_MO: record {
                victim: addr &optional;
                scanner: set[addr] &optional;
                web_host: string &optional ;
                mal_ips: set[addr] &optional;
                c_and_c: set[addr] &optional;
                culprit_conn: set[conn_id] &optional;
        } ;
	
	global struts_attack: table[string] of struts_MO ; 

	global Struts::struts_new: event( rec: struts_MO); 
	global Struts::struts_add: event( rec: struts_MO); 
}

### uncomment and exted if you desire to DROP 
#hook Notice::policy(n: Notice::Info)
#{
#  if ( n$note == HTTP::HTTP_StrutsAttack )
#        add n$actions[Notice::ACTION_DROP];
#}

@if ( Cluster::is_enabled() )
@load base/frameworks/cluster
redef Cluster::manager2worker_events += /Struts::struts_add/;
redef Cluster::worker2manager_events += /Struts::struts_new/;
@endif


@if (( Cluster::is_enabled() && Cluster::local_node_type() != Cluster::MANAGER )|| ! Cluster::is_enabled() )
event Struts::struts_add (rec: struts_MO)
{
	local domain = rec$web_host ; 

	if (rec$web_host !in struts_attack)
	{ 
		local a : struts_MO ;
		struts_attack[domain] = a ; 
		struts_attack[domain]$culprit_conn= set();
		struts_attack[domain]$mal_ips= set();
	} 
		
	struts_attack[domain]$web_host = domain;
	struts_attack[domain]$culprit_conn = rec$culprit_conn ;
	
	for (ip in rec$mal_ips)
		add struts_attack[domain]$mal_ips[ip];

	struts_attack[domain]$victim = rec$victim ; 

} 

@endif 


### manager basically distributes the record to all workers. 

@if (( Cluster::is_enabled() && Cluster::local_node_type() == Cluster::MANAGER )|| ! Cluster::is_enabled() )
event Struts::struts_new(rec: struts_MO)
{
	event Struts::struts_add(rec); 
} 

@endif 

function extract_host(url: string): string
{
        local parts = split_string(url, /\/|\?/);
        return gsub(parts[2],/\.$|:.*/,"");
}

event http_header(c: connection, is_orig: bool, name: string, value: string) &priority=5
{
	# look if the connection is from offsite and the value is content-type
        if ( !Site::is_local_addr(c$id$orig_h) && name == "CONTENT-TYPE" && detection_string in value  )
        {
                NOTICE([$note=Attempt, $id=c$id, $uid=c$uid, 
			$src=c$id$orig_h, 
			$msg=fmt("CVE-2017-5638/Struts attack from %s seen: %s", c$id$orig_h, value)]);

		if (/http/ !in value)
			return ; 


		local links = find_all_urls(value);
	
		for (a in links)
		{
			NOTICE([$note=Struts::MalwareURL,
			$conn=c, 
			$msg=fmt("Struts Hostile URLs seen in recon attempt %s to %s with URL [%s]",c$id$orig_h, c$id$resp_h, a )]); 
			#$identifier=c$uid]);

			local cmd = fmt ("%s", a);
			local uri = split_string(cmd,/ /);
			for (b in uri)
			{
				if (/http|wget|curl/ in uri[b])
				{
					local domain = extract_host(uri[b]);
					
					if (domain !in struts_attack)
					{
						local rec: struts_MO;

						struts_attack[domain] = rec;
						struts_attack[domain]$mal_ips= set();
						struts_attack[domain]$culprit_conn= set();

					}

					add struts_attack[domain]$culprit_conn[c$id];
					add struts_attack[domain]$mal_ips[c$id$orig_h];

					local a_item: Intel::Item = [$indicator=fmt("%s", c$id$orig_h), $indicator_type = Intel::ADDR, $meta = [$source = "Struts_Script", $desc="Scanning IP Address"] ];
					Intel::insert(a_item);

					if (is_valid_ip(domain) )
					{ 
						add struts_attack[domain]$mal_ips[to_addr(domain)]; 
						a_item = [$indicator=domain, $indicator_type = Intel::ADDR, $meta = [$source = "Struts_Script", $desc="Malware Download IP"] ];
						Intel::insert(a_item);
					}
					else 
					{ 
						local m_item: Intel::Item = [$indicator=domain, $indicator_type = Intel::DOMAIN, $meta = [$source = "Struts_Script",$desc="Malware download domain"] ];
						Intel::insert(m_item);
					} 
			
					struts_attack[domain]$web_host = domain;
					struts_attack[domain]$victim= c$id$resp_h ; 

				@if (( Cluster::is_enabled() && Cluster::local_node_type() != Cluster::MANAGER )|| ! Cluster::is_enabled() )
					event Struts::struts_new(struts_attack[domain]); 
				@endif 


				

				}

			}
		}
        }

}



event dns_request(c: connection, msg: dns_msg, query: string, qtype: count, qclass: count) &priority=10
{
        if (query in struts_attack)
        {
                 NOTICE([$note=Struts::HostileDomainLookup,
                                $conn=c,
                                $msg=fmt("Struts Hostile domain seen %s=%s [%s]",c$id$orig_h, c$id$resp_h, query ),
                                $identifier=c$uid]);
        }
}


event dns_A_reply(c: connection, msg: dns_msg, ans: dns_answer, a: addr) &priority=5
{
	if (ans$query in struts_attack)
	{
		add struts_attack[ans$query]$mal_ips[a]; 

@if (( Cluster::is_enabled() && Cluster::local_node_type() != Cluster::MANAGER )|| ! Cluster::is_enabled() )
		event Struts::struts_new(struts_attack[ans$query]); 
@endif 
	} 

}

event dns_AAAA_reply(c: connection, msg: dns_msg, ans: dns_answer, a: addr) &priority=5
{
	if (ans$query in struts_attack)
	{ 
		add struts_attack[ans$query]$mal_ips[a]; 

@if (( Cluster::is_enabled() && Cluster::local_node_type() != Cluster::MANAGER )|| ! Cluster::is_enabled() )
	event Struts::struts_new(struts_attack[ans$query]); 
@endif 
	} 

} 

event dns_CNAME_reply (c: connection , msg: dns_msg , ans: dns_answer , name: string ) 
{ 
	if (ans$query in struts_attack) 
	{ 	
		local domain = name ; 
		local rec: struts_MO;
		struts_attack[domain] = rec;
		struts_attack[domain]$web_host = domain ; 
		struts_attack[domain]$mal_ips = set() ; 
		struts_attack[domain]$culprit_conn= set();

@if (( Cluster::is_enabled() && Cluster::local_node_type() != Cluster::MANAGER )|| ! Cluster::is_enabled() )
		event Struts::struts_new(struts_attack[ans$query]); 
@endif 
	} 
}

event http_message_done(c: connection, is_orig: bool, stat: http_message_stat)
{
	if (! is_orig)
		return; 

        if (c$http?$host && c$http$host in struts_attack )
        {
                local vuln_url = HTTP::build_url_http(c$http);
                local domain = c$http$host ;

                NOTICE([$note=Struts::MalwareURLClick,
                                $conn=c,
                                $msg=fmt("Struts Hostile URL seen %s=%s [%s]",c$id$orig_h, c$id$resp_h, vuln_url),
                                $identifier=c$uid, $suppress_for=1 min]);

		if (struts_attack[domain]?$victim)
			struts_attack[domain]$victim= c$id$orig_h;

                if (c$id$orig_h == struts_attack[domain]$victim)
                {
                        NOTICE([$note=Struts::Compromise ,
                                        $conn=c,
                                        $msg=fmt("Struts compromise: %s=%s [%s]",c$id$orig_h, c$id$resp_h, vuln_url ),
                                        $identifier=c$uid]);
                }
        }
}


event file_state_remove(f: fa_file) &priority=-3
{
        if (f$source != "HTTP" )
                return;

        local rec: HTTP::Info ;
        local link: string = "" ;

        for (c in f$conns)
        {
                rec = f$conns[c]$http ;
                link = HTTP::build_url_http(rec);
		local domain = extract_host(link); 
	
                if (f$info?$mime_type &&  domain in struts_attack && c$resp_h in struts_attack[domain]$mal_ips && watch_mime_types in f$info$mime_type )
                 {
                        local cc = lookup_connection(rec$id);
                        local _msg=fmt("%s", link);
                        local fi = f$info;
                        local n: Notice::Info = Notice::Info($note=FileDownload, $msg=_msg, $sub=link, $conn=cc);
                        Notice::populate_file_info(f, n);
                        NOTICE(n);
                }
        }
}


### heuristics for struts-046 

#name: USER-AGENT, value: Wget/1.11.4 Red Hat modified
#name: ACCEPT, value: */*
#name: HOST, value: the.earth.li
#name: CONNECTION, value: Keep-Alive
#stat: [start=1481499233.22752, interrupted=F, finish_msg=message ends normally, body_length=0, content_gap_length=0, header_length=139]

#name: DATE, value: Sun, 11 Dec 2016 23:33:53 GMT
#name: SERVER, value: Apache
#name: LAST-MODIFIED, value: Mon, 29 Feb 2016 20:04:41 GMT
#name: ETAG, value: "81ba8-52cee28c59821"
#name: ACCEPT-RANGES, value: bytes
#name: CONTENT-LENGTH, value: 531368
#name: KEEP-ALIVE, value: timeout=5, max=100
#name: CONNECTION, value: Keep-Alive
#name: CONTENT-TYPE, value: application/x-msdos-program
#stat: [start=1481499233.376982, interrupted=F, finish_msg=message ends normally, body_length=531368, content_gap_length=0, header_length=270]

event http_header(c: connection, is_orig: bool, name: string, value: string) &priority=5
        {
		#if (name == "SERVER" && /Apache/ in Value)
		#{ 
		#print fmt ("name: %s, value: %s", name, value); 

        }

event http_message_done(c: connection, is_orig: bool, stat: http_message_stat) &priority = 5
        {
	#print fmt ("stat: %s", stat); 
	} 
